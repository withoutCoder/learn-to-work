# 微服务架构

## 微服务的优缺点

更快、更独立的服务部署，更快的项目启动，职责的服用，公共组件服务化，业务复杂度降低，业务之间解耦合。

整体系统的复杂的变高，运维难度变高，微服务治理部署耗时耗力，分布式事务的挑战。

## 服务拆分

### 纵向拆分

从业务维度进行拆分，可以理解成按功能拆分，比如消息通知模块相对其他功能比较独立，就可以单独拆出来，比如评论功能，只负责评论功能本身，就可以单独拆出来。

### 横向拆分

按照公共且独立功能维度拆分，如果有某个服务被多个其他服务调用，而且依赖的资源独立，和其他系统不耦合。当前很多中台系统的设计，都类似横向拆分。

## 微服务架构

### 服务描述

首先我们面临的第一个问题是，如何发布服务和引用服务。具体一点就是，这个服务的接口名是啥，有哪些参数，返回值是什么类型等等，通常也就是接口描述信息。

RESTful API 基于 HTTP 协议，对调用方来说几乎不需要什么学习成本，很适合用在跨平台之间的服务协议。目前使用的比较多的也是这种描述方式，不过这种方式使用的是 HTTP or HTTPS 协议，性能可能稍差，但基本是可以满足大部分场景的。

私有 RPC 协议会选择 XML 配置方式来描述接口 ，比如 Dubbo，Motan 等。服务端通过 server.xml 的方式，将文件接口暴露出去。服务消费者则通过 client.xml 引用需要调用的接口。可想而知，一个接口变动的时候，服务端客户端都需要又变动，代码入侵较高。

IDL，接口描述语言。使用中立的方式来描述接口，不同语言、不同平台的程序都可以理解接口的描述。常见的 IDL 方式有 XML、JSON、Google protobuf、Apache Thrift（facebook）。

XML：应用广泛，拓展性很强，可以定义非常复杂的结构，解析速度较慢。

JSON：结构简单，读取解析速度更快，并且支持很多预览。

protobuf：对比 XML 和 JSON 不需要解析后再映射，可以由对象直接序列化得到，并且可以直接反序列化成对象 。支持 C++、C#、Dart、Go、Java、Python、Rust 多种语言。二进制消息，性能和效率方面都跟强大，但可读性方面会稍差，但同样可以通过工具来解决。gRPC 协议当前使用的就是 protobuf 来定义接口。

Thrift：在使用性能，整体特性上与 protobuf 没什么太大差别。Thrift RPC 协议当前使用 Thrift 来定义接口。

### 服务注册中心

微服务架构里，主要有三个角色。

服务提供者（被调方）、服务调用者（调用方）、服务注册中心。

如果被调方发布了一个服务，调用方应该怎么找到服务的地址呢？

在没有注册中心之前，可以使用 DNS 帮助调用方发现服务。但 DNS 明显做不到试试更新服务、端口级别的服务发现。

微服务框架中，服务注册中心是个极其重要的角色。主要的职责就是用于服务注册与发现。

#### 注册中心基本的使用流程

首先，服务启动的时候，在注册中心注册下自己的服务，并且定期的向注册服务发送心跳，确保自己的存活状态。

其次，客户端调用服务的时候，会向注册中心订阅该服务，并且将节点的列表保存在本地，在与服务器建立连接。真正发起调用的时候，会在本地缓存的节点列表里，基于负载均衡算法选取一台服务发起调用。

当服务节点发生变更的时候，注册中心会通过心跳机制感知到，并且通知客户端。

#### 注册中心的实现需要解决的问题

##### 注册中心节点之间的一致性与可用性

分布式系统的老生常谈，关于一致性、可用性、分区容错性的问题。

我们都知道，CAP 是不可能同时满足的，一般来说我们不会放弃分布式系统的分区容错性。所以一般的注册中心也就分为 CP 注册中心与 CA 注册中心。

CP 注册中心还是很多的，典型的就是 ZooKeeper 和 Etcd，牺牲了可用性用来保证一致性和分区容错性。通过 zab 协议或者 raft 协议来实现。

通过牺牲一致性来保证可用性的注册中心可以想到的只有 eureka 了。eureka 每个节点会单独保存节点列表，会出现不一致的情况，只能保证最终一致性。

理论上，对于注册中心来说，可用性的需求大于一致性，因为服务就算无法保证强一致性，客户端其实是可以通过一些容错策略来弥补的。比如客户端在检查到服务端某个节点不可达时，可以更换其他节点访问。而可用性一旦失去了，注册中心就失去了其应有的能力。

##### 注册与发现的方式

应用内集成到 SDK 的方式，应用外使用 Agent 的方式。

比如如果使用 Zookeeper 做注册中心，则可以使用 curator sdk 进行注册和发现。

如果使用 consul 作为注册中心，则可以使用 consul agent 负责监听服务状态，并实现与注册中心的交互。

对于容器化的云应用来说，一般不会使用 SDK 解决方案，因为会入侵业务代码。一般这种情况更多会考虑使用 agent 的方式来进行服务注册。

##### 服务健康检测如何实现

客户端心跳：客户端可以每隔一段时间主动向服务端发送心跳（TCP or HTTP），表明自己还活着。也可以通过长连接的方式来实现心跳。

服务主动探测：服务端调用服务发布者 HTTP 接口，来完成健康检测。如果应用没有 HTTP 服务，比如是个 RPC 应用。服务端可以通过调用 RPC 服务的某个接口实现健康检测。

各个注册中心是如何实现的：

Eureka 配置中心是支持可配置的。

Zookeeper 通过长连接，定期发送连接心跳以保持会话 （Session），会话本身具有存活时间，每次心跳会刷新会话 存活时间；

Etcd 通过连接心跳来支持的健康检查。

Nacos 可以通过传输层协议 TCP、PING 或应用层协议 HTTP、自定义的方式进行健康检测。

##### 状态变更如何通知给客户端

Zookeeper 支持服务器端推送变化，其它都通过长轮询的方式来实现变化的感知。

##### 注册中心选型

Eureka 是典型的 AP，Nacos可以配置为 AP，作为分布式场景下的服务发现的产品较为合适，服务发现场景的可用性优先级较高，一致性并不是特别致命。

而Zookeeper、Etcd、Consul则是 CP 类型牺牲可用性，在服务发现场景并没太大优势；

### 服务框架



### 服务监控

基础层监控：对主机、容器底层资源进行监控，监控的对象是系统的 I/O 李永利，CPU 利用率，内存利用率，网络负载等。

中间层监控：对 Redis、MySQL、消息中间件之类的中间件软件进行监控。

应用层监控：对应用程序的业务服务进行监控，监控对象是接口请求访问情况（耗时、吞吐量），JVM 监控，服务健康状态，服务链路监控（服务追踪）。

### 服务全链路追踪

服务追踪的实现主要包括三部分：埋点数据收集、实时数据处理、数据链路展示。

链路追踪的基本实现：首先，每个请求的入口出口进行埋点数据收集，记录调用之间的关系和调用时间等信息。然后通过实时处理收集到的数据，梳理出一次请求的完整链路。可视化调用拓扑和调用链。

埋点数据之间通过 Traceid 来唯一标识一条链路，通过 spanid + parentid 表示调用之间的父子关系，通过 TimeStamp 记录当前调用时间戳。

全链路追踪一般通过 Skywalking 或者 Pinpoint 来实现。

这两个 APM （Application Performance Management 即应用性能管理）框架都是完全无侵入式的。

Skywalking  发起人是中国人（吴晟），Pinpoint 发起人是韩国人。

从社区层面上来说，Skywalking  已经进入 apache 孵化，切社区很活跃，对于国内来说直接无脑 Skywalking  即可。

语言支持层面上 Skywalking 支持更广泛。在协议上，Skywalking 支持 gRPC + HTTP（6.x只支持 gRPC），Pinpoint 使用 Thrift。

这两个 APM 最大的差别在于存储上。Skywalking 支持多种存储方式，而 Pinpoint 只支持 HBase。由于 HBase 查询能力的限制，Skywalking 在查询维度上也优于 Pinpoint。

### 服务治理

微服务治理平台会包含以下模块

注册中心（服务管理）Nacos、Eureka 

配置中心（服务治理）限流、降级、熔断、异地容灾

监控系统（服务监控）各层级监控

服务追踪（问题定位）Skywalking、Pinpoint

日志查询（日志系统）ELK

容器管理平台（服务运维）Kubernetes 

